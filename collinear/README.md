三个文件

输入是一系列的点，要求从中找出所有的线（由四个及四个以上的点组成），其中必须是最长的线，如p->q-r->z->m，那么就不能输出p->q-r->z之类

其中要注意的一点是关于浮点数的比较，比较是否相等时，不要用==，会有误差，应该用两者差值的绝对值去比较threshold，如果小于，就表示相等，根据本题的数据特点，这个threshold需要定的相当小

## BruteCollinearPoints

是采取四层循环，如果四个点共线，就添加。根据specification，这里提供的数据没有四个点以上的线，所以不用考虑其他情况。

## FastCollinearPoints

基本思路是：对于每一个点，把所有的点根据与这个点的连线斜率排序，然后从Index=2开始往后遍历，只要是斜率等于与index=1的点的连线斜率，就作为该线的一个点，直到遇到连线斜率不相同的点，表示该斜率的线上的点已经收集完毕，现在只要判断点的数量，如果大于等于4，就作为一条线，但是要创建一个线段的object，我们需要的是两个端点，因为需要对这些点根据自然序（从左到右，从下到上）排序，但在真正加入list之前，还需要做一件事，就是判断排序之前的第一个点，是否是排序之后的第一个点，这个操作是为了去重，因为之前这些点并不是自然序的，例如一条线是p->q->r->s,我们找到的点可能是r,q,p,s,但是排序之后仍然是p->q->r->s，而当我们找到p,q,r,s时，我们就会重复添加线，因此，只有当排序之前的点就是自然序的第一个点，我们才把他加入list，这样就不会重复。

## Point

slopeto函数值得注意